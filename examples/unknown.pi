import util.
%module unknown.

/* DWG field packing problem, the solver in picat-lang.org
   See https://www.gnu.org/software/libredwg/ examples/unknown

   At first fix all positions for unique finds: BL93,H330,BL92.
   TODO Error if there's a conflict already.

   Then check for all multiple finds if the number of finds is the same as the
   number of equal values: BL90,BL96,BL97. Distribute it then.

   TODO Then pack the possible others optimally (smallest amount of missing holes),
   with backtracking.

   Print the final layout of fixed and open ranges in dwg.spec syntax.
   TODO: sort by pos, fill holes by probable types.

   Compare to all examples of the same class.
*/

go(S,Fields) =>
  Found = [],
  Possible = [],
  println(S), nl,
  foreach(Sub in Fields)
    print(Sub.name), print(" "), print(Sub[2]), println(": "++Sub[1]),
    PosList = findall([Start,End], find(S,Sub[1],Start,End)),
    Sub[3] := PosList,
    if PosList.length = 1 then
      Found := add_found(PosList[1],Found), % checks overlap
      println(fixed=first(Sub[3])),
      %println(fixed=Found),
      % for each found range delete now invalid ranges in all fields.
      % ie H360 [206,213]
      Pos = PosList[1], %print(pos=Pos),
      foreach(S1 in Fields, S1[3].length > 1, Sub != S1)
        %println(pre=S1),
        Before = [P1: P1 in S1[3], P1[2] < Pos[1]],
        After  = [P2: P2 in S1[3], P2[1] > Pos[2]],
        %print(before=Before),print(after=After),println(curr=S1[3]),
        append(Before, After, T), S1[3] := T
        %println(post=S1)
      end
    else
      print(PosList.length), print(" "),println(positions=PosList),
      % check for matching number of multiple values
      N := same_values(Fields, Sub), % all Subs with same values
      if N.length = PosList.length then
        print("distribute positions: "),
        I = 1,
        foreach(X in N)
          X3 = X[3],
          print(X.name),print(" "),
          Found := add_found(X3[I],Found),
          X[3] := [PosList[I]], % collapse to single entry
          I := I + 1
        end,
        nl
      end
    end,
    %println(fixed=Found),
    nl
  end,

  % TODO Then pack the possible others optimally (smallest amount of missing holes),
  % with backtracking.
    
  % Print the final layout of fixed and open ranges
  println(fixed=Found),
  % TODO: sort by pos, fill holes by probable types
  foreach (Sub in Fields)  
    println(field=Sub)
  end,
  nl.

% list of same values and number of solutions of Sub in Fields
same_values(Fields, Sub) =
  % needs to use , for /\ here: "compound condition". ; would be or
  [X : X in Fields, X[3].length == Sub[3].length, X[1] = Sub[1]].

% check valid ranges,
% add found pos if not already in.
% change Found inline, keep Found sorted.
add_found(Pos, []) = [Pos].
add_found(Pos, Found) = List =>
  %print("add_found "),print(pos=Pos),print(" "),println(found=Found),
  % sort Pos into Found: pos = [33,42] found = [[192,199]]
  Before = [X1: X1 in Found, Pos[1] > X1[1], Pos[2] > X1[1]],
  append(Before, [Pos], T1), List = T1,
  % and the remaining elems behind. pos = [43,52] found = [[33,42],[192,199]]
  Behind = [X2: X2 in Found, Pos[1] < X2[1], Pos[2] < X2[1]],
  append(List, Behind, T2), List := T2,
  if Found.length != List.length-1 then
    println("overlap"), List := Found
  end.
